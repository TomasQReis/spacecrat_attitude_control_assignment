%% Initializes
clc
clear;
close all;

%% Environment
mu                  = 3.986004418e5;     % km^3/s^-2
semiMajor           = 700 + 6378; % km

meanMot             = mean_mot(mu, semiMajor);
J                   = [124.531, 0, 0;
                         0, 124.586, 0;
                         0, 0, 0.704];

%% Propagation
timeStep            = 0.01;             % Seconds
timeFinal           = 200;              % Seconds

times               = 0:timeStep:timeFinal;
numRows             = size(times);

%% Reality Simulation Variables and description. 
syms xReal [7 1] real
syms trqs [3 1] real

% Real state change function.
% Used for propagating system dynamics (Outside of control) 
function xDotReal = fRealFunc(~, xReal, trqs, J, meanMot)
    xDotReal = [0.5 * (xReal(2)*(xReal(7)) - xReal(3)*(xReal(6)) + xReal(4)*(xReal(5)));
         0.5 * (-xReal(1)*(xReal(7) ) + xReal(3)*(xReal(5)) + xReal(4)*(xReal(6) ));
         0.5 * (xReal(1)*(xReal(6) ) - xReal(2)*(xReal(5)) + xReal(4)*(xReal(7) ));
         0.5 * (-xReal(1)*(xReal(5)) - xReal(2)*(xReal(6) ) - xReal(3)*(xReal(7) ));
         1/J(1,1) * (3*meanMot^2 * (-J(2,2)*2*(xReal(2)*xReal(3) + xReal(1)*xReal(4))*(1 - 2*(xReal(1)^2 + xReal(2)^2)) + J(3,3)*(1 - 2*(xReal(1)^2 + xReal(2)^2))*2*(xReal(2)*xReal(3) + xReal(1)*xReal(4))) + trqs(1) - (-J(2,2)*(xReal(5))*(xReal(7) ) + J(3,3)*(xReal(7) )*(xReal(6) )));
         1/J(2,2) * (3*meanMot^2 * (J(1,1)*2*(xReal(1)*xReal(3) + xReal(2)*xReal(4))*(1 - 2*(xReal(1)^2 + xReal(2)^2))) + J(3,3)*(2*(xReal(2)*xReal(3) + xReal(1)*xReal(4))*2*(xReal(1)*xReal(3) + xReal(2)*xReal(4))) + trqs(2) - (J(1,1)*(xReal(6) )*(xReal(7) ) - J(3,3)*(xReal(7) )*(xReal(5) )));
         1/J(3,3) * (3*meanMot^2 * (-J(1,1)*2*(xReal(1)*xReal(3) + xReal(2)*xReal(4))*2*(xReal(2)*xReal(3) + xReal(1)*xReal(4)) + J(2,2)*2*(xReal(2)*xReal(3) + xReal(1)*xReal(4))*2*(xReal(1)*xReal(3) + xReal(2)*xReal(4))) + trqs(3) - (-J(1,1)*(xReal(5) )*(xReal(6) ) + J(2,2)*(xReal(6) )*(xReal(5) )));];
end

%% MEKF variables and descriptions. 
% MEKF global state variables. 
syms qEKF [4 1]
syms wBiasEKF [3 1]
syms t wMeas [3 1] real
% Global state description. 
fGlobalEKF = [0.5 * (qEKF(2)*(wMeas(3)-wBiasEKF(3)) - qEKF(3)*(wMeas(2)-wBiasEKF(2)) + qEKF(4)*(wMeas(1)-wBiasEKF(1)));...
        0.5 * (-qEKF(1)*(wMeas(3)-wBiasEKF(3)) + qEKF(3)*(wMeas(1)-wBiasEKF(1)) + qEKF(4)*(wMeas(2)-wBiasEKF(2)));...
        0.5 * (qEKF(1)*(wMeas(2)-wBiasEKF(2)) - qEKF(2)*(wMeas(1)-wBiasEKF(1)) + qEKF(4)*(wMeas(3)-wBiasEKF(3)));...
        0.5 * (-qEKF(1)*(wMeas(1)-wBiasEKF(1)) - qEKF(2)*(wMeas(2)-wBiasEKF(2)) - qEKF(3)*(wMeas(3)-wBiasEKF(3)));...
        0; 0; 0];

% Global state function as matlab function. Just to be able to use ode45. 
function xDotEKF = fEKFFunc(~, xGlobalEKF, wMeas)
    xDotEKF = [0.5 * (xGlobalEKF(2)*(wMeas(3)-xGlobalEKF(7)) - xGlobalEKF(3)*(wMeas(2)-xGlobalEKF(6)) + xGlobalEKF(4)*(wMeas(1)-xGlobalEKF(5)));...
        0.5 * (-xGlobalEKF(1)*(wMeas(3)-xGlobalEKF(7)) + xGlobalEKF(3)*(wMeas(1)-xGlobalEKF(5)) + xGlobalEKF(4)*(wMeas(2)-xGlobalEKF(6)));...
        0.5 * (xGlobalEKF(1)*(wMeas(2)-xGlobalEKF(6)) - xGlobalEKF(2)*(wMeas(1)-xGlobalEKF(5)) + xGlobalEKF(4)*(wMeas(3)-xGlobalEKF(7)));...
        0.5 * (-xGlobalEKF(1)*(wMeas(1)-xGlobalEKF(5)) - xGlobalEKF(2)*(wMeas(2)-xGlobalEKF(6)) - xGlobalEKF(3)*(wMeas(3)-xGlobalEKF(7)));...
        0; 0; 0];
end


% MEKF error state variables. 
syms qError [3 1]
syms wBiasError [3 1]
% Error state description. 
fErrorEKF = [-(wMeas(3)-wBiasEKF(3))*qError(2) + (wMeas(2)-wBiasEKF(2))*qError(3) - wBiasError(1);...
             (wMeas(3)-wBiasEKF(3))*qError(1) - (wMeas(1)-wBiasEKF(1))*qError(3) - wBiasError(2);...
             -(wMeas(2)-wBiasEKF(2))*qError(1) + (wMeas(1)-wBiasEKF(1))*qError(2) - wBiasError(3);
             0; 0; 0];

% Jacobian function of error state description.  
FErrorEKF = matlabFunction(jacobian(fErrorEKF, [qError; wBiasError]), 'Vars', {qError, wMeas, wBiasError, wBiasEKF});

%% Observation vector. 
syms qVector 
hEKF =  [atan2( 2*(qEKF(4)*qEKF(1)+qEKF(2)*qEKF(3)), 1-2*(qEKF(1)^2+qEKF(2)^2) );
         asin(  2*(qEKF(2)*qEKF(4)-qEKF(1)*qEKF(3)) );
         atan2( 2*(qEKF(1)*qEKF(2)+qEKF(3)*qEKF(4)), 1-2*(qEKF(2)^2+qEKF(3)^2) )];

% Observation vector function. 
function zVec = hEKFFunc (qEKF)
    zVec =  [atan2( 2*(qEKF(4)*qEKF(1)+qEKF(2)*qEKF(3)), 1-2*(qEKF(1)^2+qEKF(2)^2) );
         asin(  2*(qEKF(2)*qEKF(4)-qEKF(1)*qEKF(3)) );
         atan2( 2*(qEKF(1)*qEKF(2)+qEKF(3)*qEKF(4)), 1-2*(qEKF(2)^2+qEKF(3)^2) )];
end

% Submatrix of complete observation Jacobian.  
dHdq = jacobian(hEKF, qEKF);
dqdq_Error = 0.5* [qEKF(4), -qEKF(3), qEKF(2);
                  qEKF(3), qEKF(4), -qEKF(1);
                  -qEKF(2), qEKF(1), qEKF(4);
                  -qEKF(1), -qEKF(2), -qEKF(3)];
dHdwBias = jacobian(hEKF, wBiasEKF);

% Complete observation jacobian matrix. 
HMatxEKF = matlabFunction(horzcat(dHdq * dqdq_Error, dHdwBias) , ...
    'Vars', {qEKF});


%% Sensor characteristics. 
% Euler angle std deviations.  
thetaNoiseSTDev = deg2rad(0.1) * ones([1,3]);

% Quaternion std deviations for initialization of P matrix.
theta1Noises = thetaNoiseSTDev(1) * randn(numRows(2),1);
theta2Noises = thetaNoiseSTDev(2) * randn(numRows(2),1);
theta3Noises = thetaNoiseSTDev(3) * randn(numRows(2),1);
thetaNoise = [theta1Noises, theta2Noises, theta3Noises];

% Angular rate bias. 
wBias = deg2rad([0.1, -0.1, 0.15]);

% Initializes EKF R matrix. 
RMatx = diag(thetaNoiseSTDev);

% Initializes EKF P matrix. (P00)
P_k_k = diag([thetaNoiseSTDev, 0, 0, 0]);

% Creates a random walk matrix to use for wBias. 
sigmaBias = deg2rad(0.0005);  
walkMatrix = blkdiag(zeros(3), sigmaBias^2 * eye(3));

%% Initial Conditions %% 
% Initial euler angles. 
theta1 = deg2rad(5); theta2 = deg2rad(5); theta3 = deg2rad(5);

% Creates angular velocity vector of LVLH frame wrt inertial (J2000).
% Defined within Body frame. 
wOrbital = - meanMot * [...
    cos(theta2)*sin(theta3),...
    sin(theta1)*sin(theta2)*sin(theta3) + cos(theta1)*cos(theta3), ... 
    cos(theta1)*sin(theta2)*sin(theta3) - sin(theta1)*cos(theta3), ...
    0];

% Assumes initial qDot=0. 
qDot = [0, 0, 0, 0];
% Converts initial euler attitude angles to quaternion.
qInit = eul_to_quat([theta1, theta2, theta3]);

% Obtains initial omega vector. 
Q = [qInit(4), -qInit(3), qInit(2), qInit(1);
     qInit(3), qInit(4), -qInit(1), qInit(2);
     -qInit(2), -qInit(1), qInit(4), qInit(3);
     -qInit(1), -qInit(2), -qInit(3), qInit(4)];

w = ((2 *Q.' *qDot.') + wOrbital.').';

%% Initial Measurements. 
% Creates initial error quaternion and applies. 
qInitError = eul_to_quat([theta1Noises(1), theta2Noises(1), ...
                         theta3Noises(1)]);
qInitMeasure = quat_mul(qInitError, qInit);

%% State array initialization. 
% Reality state.
stateReal       = zeros(7, numRows(2));

% EKF ----
% Global state.
qEKF                    = zeros(4, numRows(2));
wBiasEKF                = zeros(3, numRows(2));
% Error state. 
qError                  = zeros(3, 1);
wBiasError              = zeros(3, 1);

% Measurement vectors. 
zEKF                    = zeros(4, numRows(2));

%% Initial values
% Reality state. 
stateReal(1:4, 1)       = qInit.';
stateReal(5:7, 1)       = w(1:3).';

% EKF ----
% Initial global state prediction. 
qEKF(:,1) = [1,1,1,1] / norm([1,1,1,1]);
wBiasEKF(:,1) = zeros(1,3);

% Initial value for measured quaternions 
zEKF(:, 1) = qEKF(:,1);

% Initial control torque. 
ctrlTorque = zeros(1, 3);

%% Input array for ode45.
timespan = [0 timeStep];

%% Number of iterations for error finding. 
numIters = 1;

%% Controller values.
% Controller Gains
Kq              = 30;                        % Quaternion gain.
Kw              = 50;                        % Angular rate gain

% Controller Targets
eulerTarget     = [0;0;0];                  % rad
qTarget         = eul_to_quat(eulerTarget);     
wTarget         = [0;0;0];

%% Analysis variables.
% Vector of real euler angles. 
ctrlEuler       = zeros(3, numRows(2));
% Vector of real euler angle accuracy (error).
ctrlEulerError  = zeros(3, numRows(2));

% Initial values. 
ctrlEuler(:,1)      = quat_to_eul(stateReal(1:4,1));
ctrlEulerError(:,1) = ctrlEuler(:,1) - eulerTarget;

for i = 1:numRows(2)-1
    %% Propagation of real state.
    % Uses torques from previous step to propagate to next.  ---//---
    [~, xRealOdeOutput] =  ode45(@(t,xReal) fRealFunc(t, xReal, ctrlTorque, J, meanMot), ...
        timespan, [stateReal(:,i)]);
    stateReal(:, i+1) = xRealOdeOutput(end,:);

    % Apply bias and noise to measurements.   ---//---
    % wMeasured not saved since only required for input. 
    wMeasured = stateReal(5:7, i) + wBias.';
    % Noise added to Euler angles. 
    zEKF(:,i+1) = eul_to_quat(quat_to_eul(stateReal(1:4,i+1)) + thetaNoise(i+1,:).');

    % Saves current error in Euler angles. 
    % Note that this does slow the code a bit but it wouldn't be part of
    % the main controller anyway. Just for show. 
    ctrlEuler(:,i+1)      = rad2deg(quat_to_eul(stateReal(1:4,i+1)));
    ctrlEulerError(:,i+1) = ctrlEuler(:,i+1) - rad2deg(eulerTarget);

    %% EKF Portion.
    % Prediction of next state. ---//---
    [~, xEKFOdeOutput] =  ode45(@(t,xGlobal) fEKFFunc(t,xGlobal, wMeasured), timespan, [qEKF(:,i);wBiasEKF(:,i)]);
    
    % Assigns results of ode to non-corrected global state prediction. 
    qEKF(:,i+1) = xEKFOdeOutput(end,1:4);
    wBiasEKF(:,i+1) = xEKFOdeOutput(end,5:7);
    % Calculates predicted measurement vector. 
    zPredicted = qEKF(:,i+1);

    % Guarantees same hemisphere for both measurement quaternions.
    if dot(zEKF(:,i+1), zPredicted) < 0
        zEKF(:,i+1) = -zEKF(:,i+1);
    end

    % Resets error state.  
    errorState = zeros(6,1);
    
    for j = 1:numIters
        %% Iterative error finding. ---//---

        % Update covariance matrix. ---//---
        % Jacobian matrix of error state. 
        FMatxEKF_i = FErrorEKF(qError, wMeasured, wBiasError, wBiasEKF(:,i+1));
        % Calculate phi matrix. 
        phiMatx = eye(6) + timeStep*FMatxEKF_i;
        % Update covariance matrix.
        P_k1_k = phiMatx * P_k_k * phiMatx.' + walkMatrix;
        
    
        % Update Kalman gain matrix. ---//---
        % H matrix for current step. (Using euler h function)
        % H_k1 = HMatxEKF(qEKF(:,i+1));
        % H matrix using previous Euler to quaternion conversion. 
        H_k1 = [eye(3), zeros(3)];

        % Update Kalman gain matrix. 
        K_k1 = P_k1_k*H_k1.' / (H_k1*P_k1_k*H_k1.' + RMatx);
    
        % Innovation vector using quaternion error. 
        qErr = quat_mul(zEKF(:,i+1), quat_conj(zPredicted));

        % Small-angle residual
        delta_z = 2 * qErr(1:3);
       
        % Update error state. ---//---
        % Assumes reset errors on each time-step.
        %errorState = errorState + K_k1*(zEKF(:,i+1) - zPredicted - H_k1*[qError; wBiasError]);
        errorState = errorState + K_k1*(delta_z);
        qError = errorState(1:3);
        wBiasError = errorState(4:6);

        % Obtains error quaternion. 
        qErrorQuat = [qError; 1];
    
        % Applying error state to non-corrected global states. 
        qEKF(:, i+1) = quat_mul(qEKF(:, i+1), qErrorQuat);
        wBiasEKF(:, i+1) = wBiasEKF(:, i+1) + wBiasError;
    
        % Normalizes quaternion vector. 
        qEKF(:, i+1) = qEKF(:, i+1) / norm(qEKF(:, i+1));
    
        % Update error covariance matrix. ---//---
        P_k_k = (eye(6) - K_k1*H_k1)*P_k1_k;
    end

    %% Controller logic. 
    % Calculates quaternion error via multiplication of ekf x target. 
    qControlError = quat_mul(qEKF(:, i+1), qTarget);
    
    % Calculates angular rate error using measurement and bias. 
    wControlError = (wMeasured - wBiasEKF(:, i+1)) - wTarget;

    %Obtains control torque using errors. 
    ctrlTorque = - (Kq*qControlError(1:3) + Kw * wControlError);

    %% Just for fun.
    if times(i) > 100
        eulerTarget = deg2rad([10;10;10]);
        qTarget = eul_to_quat(eulerTarget);
    end

end


%% Quaternion plots. 
figure
subplot(2,2,1)
hold on
plot( times, stateReal(1,:),"r")
plot( times, qEKF(1,:), "g.-")
legend({"Real q4.", "EKFiltered q1."})
subplot(2,2,2)
hold on
plot( times, stateReal(2,:),"r")
plot( times, qEKF(2,:), "g.-")
legend({"Real q4.", "EKFiltered q2."})
subplot(2,2,3)
hold on
plot( times, stateReal(3,:),"r")
plot( times, qEKF(3,:), "g.-")
legend({"Real q4.", "EKFiltered q3."})
subplot(2,2,4)
hold on
plot( times, stateReal(4,:),"r")
plot( times, qEKF(4,:), "g.-")
legend({"Real q4.", "EKFiltered q4."})

%% Angular rate plots. 
figure
subplot(3,1,1)
hold on
plot( times, stateReal(5,:),"b--")
plot( times, wBias(1)*ones(size(times)),"r")
plot( times, wBiasEKF(1,:), "g.-")
legend({"W1 Real.", "W1 Bias.", "W1 Bias Estimate."})
subplot(3,1,2)
hold on
plot( times, stateReal(6,:),"b--")
plot( times, wBias(2)*ones(size(times)),"r")
plot( times, wBiasEKF(2,:), "g.-")
legend({"W2 Real.","W2 Bias.", "W2 Bias Estimate."})
subplot(3,1,3)
hold on
plot( times, stateReal(7,:),"b--")
plot( times, wBias(3)*ones(size(times)),"r")
plot( times, wBiasEKF(3,:), "g.-")
legend({"W3 Real.","W3 Bias.", "W3 Bias Estimate."})

%% Euler angle plots. 
figure
subplot(3,1,1)
hold on
plot( times, ctrlEuler(1,:),"r")
plot( times, ctrlEulerError(1,:),"b--")
legend("Real \theta_1", "\theta_1 Error")
grid()
subplot(3,1,2)
hold on
plot( times, ctrlEuler(2,:),"r")
plot( times, ctrlEulerError(2,:),"b--")
legend("Real \theta_2", "\theta_2 Error")
grid()
subplot(3,1,3)
hold on
plot( times, ctrlEuler(3,:),"r")
plot( times, ctrlEulerError(3,:),"b--")
legend("Real \theta_3", "\theta_3 Error")
grid()
