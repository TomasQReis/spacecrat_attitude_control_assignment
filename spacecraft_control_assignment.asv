%% Initializes
clc;
clear all;
close all;

%% Environment
mu = 3.986004418e5;     % km^3/s^-2
semiMajor = 700 + 6378; % km

timeStep = 0.1;         % Seconds
timeFinal = 1000;       % Seconds

meanMot = mean_mot(mu, semiMajor);
J = [124.531, 0, 0;
     0, 124.586, 0;
     0, 0, 0.704];

%% Initial Conditions %% 
% Initial euler angles. 
theta1 = 5*pi/180; theta2 = 5*pi/180; theta3 = 5*pi/180;

% Creates angular velocity vector of LVLH frame wrt inertial (J2000).
% Defined within Body frame. 
wOrbital = - meanMot * [...
    cos(theta2)*sin(theta3),...
    sin(theta1)*sin(theta2)*sin(theta3) + cos(theta1)*cos(theta3), ... 
    cos(theta1)*sin(theta2)*sin(theta3) - sin(theta1)*cos(theta3), ...
    0];

% Converts initial euler attitude angles to quaternion.
qInit = eul_to_quat(theta1, theta2, theta3);

% Assumes initial qDot=0. 
qDot = [0, 0, 0, 0];

% Obtains initial omega vector. 
Q = [qInit(4), -qInit(3), qInit(2), qInit(1);
     qInit(3), qInit(4), -qInit(1), qInit(2);
     -qInit(2), -qInit(1), qInit(4), qInit(3);
     -qInit(1), -qInit(2), -qInit(3), qInit(4)];

wInit = ((2 *Q.' *qDot.') + wOrbital.').';
wDotInit = w_dot(J, meanMot, qInit, wInit, [0,0,0]).';

% Initializes empty vectors to their final size. 
times = 0:timeStep:timeFinal;
numRows = size(times);
qArr = zeros(numRows(2), 4);
wArr = zeros(numRows(2), 4);

% Places initial values as first row in the array. 
qArr(1,:) = qInit;
wArr(1,:) = wInit;
wDotArr(1,:) = wDotInit;

% Initializes target quaternion. 
qTarget = eul_to_quat(0, 0, 0);

% Defines controller gains. 
K0 = 0.05;
K = 2;
K1 = K; K2 = K; K3 = K;

for i = 1:numRows(2)-1

    % Updates control torque. 
    qError = quat_mul(qArr(i,:), qTarget);
    t1 = -(K0 * qError(1) + K1 * wArr(i,1));
    t2 = -(K0 * qError(2) + K2 * wArr(i,2));
    t3 = -(K0 * qError(3) + K3 * wArr(i,3));
    controlTorque = [t1, t2, t3];
    %controlTorque = [0,0,0];

    % Updates states for uncontrolled system. 
    wArr(i+1,:) = (wArr(i,:) + timeStep*wDotArr(i,:));
    qDot = q_dot(wArr(i+1,:), qArr(i,:));
    qArr(i+1,:) = (qArr(i,:) + (timeStep*qDot).');
    qArr(i+1,:) = qArr(i+1,:)/norm(qArr(i+1,:));
    wDotArr(i+1,:) = w_dot(J, meanMot, qArr(i+1,:), wArr(i+1,:),...
                           controlTorque);

end



figure
subplot(2,2,1)
plot( times, qArr(:, 1))
subplot(2,2,2)
plot( times, qArr(:, 2))
subplot(2,2,3)
plot( times, qArr(:, 3))
subplot(2,2,4)
plot( times, qArr(:, 4))

%% FUNCTIONS %%
% Verified. 
% Mean motion of orbit with given semiMajor around body mu. 
function meanMot = mean_mot(mu, semiMajor)
    meanMot = sqrt(mu / semiMajor^3);
end

% Verified. 
% Quaternion matrix multiplication function. 
% Follows the notation where q_4 is the real part of the quaternion. 
function quatMul = quat_mul(quatCurrent, quatTarget)
    intermMatrix = [quatTarget(4), quatTarget(3), -quatTarget(2), -quatTarget(1);
                    -quatTarget(3), quatTarget(4), quatTarget(1), -quatTarget(2);
                    quatTarget(2), -quatTarget(1), quatTarget(4), -quatTarget(3);
                    quatTarget(1), quatTarget(2), quatTarget(3), quatTarget(4)];
    quatMul = (intermMatrix * quatCurrent.').';
end

% Verified. 
% Euler to quaternion transformation. 
function quat = eul_to_quat(theta1, theta2, theta3)

    % Precompute half-angles. 
    t1 = theta1/2;
    t2 = theta2/2;
    t3 = theta3/2;

    % sines and cosines of half-angles. 
    c1 = cos(t1);  s1 = sin(t1);
    c2 = cos(t2);  s2 = sin(t2);
    c3 = cos(t3);  s3 = sin(t3);

    % Quaternion components. 
    q1 =  s1*c2*c3  -  c1*s2*s3;
    q2 =  c1*s2*c3  +  s1*c2*s3;
    q3 =  c1*c2*s3  -  s1*s2*c3;
    q4 =  c1*c2*c3  +  s1*s2*s3;

    % Pack into a row-vector. 
    quat = [q1, q2, q3, q4];
end

% Verified
% Outputs angular velocity change vector. 
function wDot = w_dot(J, meanMot, q, w, controlTorque)
    % Defines cosine matrix elements via quaternion elems.
    C13 = 2*(q(1)*q(3) + q(2)*q(4));
    C23 = 2*(q(2)*q(3) + q(1)*q(4));
    C33 = 1 - 2*(q(1)^2 + q(2)^2);
   
    % Defines intermediate matrices. 
    C = [0, -C33, C23;
        C33, 0, -C13;
        -C23, C13, 0];
    W = [0, -w(3), w(2);
         w(3), 0, -w(1);
         -w(2), w(1), 0];

    leftSide = 3*meanMot^2*C*J*[C13;C23;33];
    rightSide = [0.001; 0.001; 0.001] - W*J*w(1:3).';

    wDot = [inv(J)*((leftSide + rightSide + controlTorque.')); 0];
end

% Outputs q_dot matrix. 
function qDot = q_dot(w, q)

    omegaMatrix = [0, w(3), -w(2), w(1);
                   -w(3), 0, w(1), w(2);
                   w(2), -w(1), 0, w(3);
                   -w(1), -w(2), -w(3), 0];

    qDot = 0.5 * omegaMatrix * q.';
end