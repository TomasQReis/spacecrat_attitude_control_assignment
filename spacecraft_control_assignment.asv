%% Environment
mu = 3.986004418e5;     % km^3/s^-2
semiMajor = 700 + 6378; % km

timeStep = 0.1;         % Seconds
timeFinal = 1000;       % Seconds

meanMot = mean_mot(mu, semiMajor);
J = [124.531, 0, 0;
     0, 124.586, 0;
     0, 0, 0.704];

%% Initial Conditions %% 
% Initial euler angles. 
theta1 = 20*pi/180; theta2 = 20*pi/180; theta3 = 20*pi/180;

% Creates angular velocity vector of LVLH frame wrt inertial (J2000).
% Defined within Body frame. 
wOrbital = - meanMot * [...
    cos(theta2)*sin(theta3),...
    sin(theta1)*sin(theta2)*sin(theta3) + cos(theta1)*cos(theta3), ... 
    cos(theta1)*sin(theta2)*sin(theta3) - sin(theta1)*cos(theta3), ...
    0];

% Converts initial euler attitude angles to quaternion.
qInit = eul_to_quat(theta1, theta2, theta3);

disp(qInit)

% Assumes initial qDot=0. 
qDot = [0, 0, 0, 0];

% Obtains initial omega vector. 
Q = [qInit(4), -qInit(3), qInit(2), qInit(1);
     qInit(3), qInit(4), -qInit(1), qInit(2);
     -qInit(2), -qInit(1), qInit(4), qInit(3);
     -qInit(1), -qInit(2), -qInit(3), qInit(4)];

wInit = ((2 *Q.' *qDot.') + wOrbital.').';
wDotInit = w_dot(J, meanMot, qInit, wInit.').';

% Initializes empty vectors to their final size. 
times = 0:timeStep:timeFinal;
numRows = size(times);
qArr = zeros(numRows(2), 4);
wArr = q; wDotArr = q;

% Places initial values as first row in the array. 
qArr(1,:) = qInit;
wArr(1,:) = wInit;
wDotArr(1,:) = wDotInit;

for i = 1:numRows(2)

    wArr(i+1,:) = wArr(i,:) + timeStep*wDotArr(i,:);


end

%% FUNCTIONS %%
% Verified. 
% Mean motion of orbit with given semiMajor around body mu. 
function meanMot = mean_mot(mu, semiMajor)
    meanMot = sqrt(mu / semiMajor^3);
end

% Verified. 
% Quaternion matrix multiplication function. 
% Follows the notation where q_4 is the real part of the quaternion. 
function quatMul = quat_mul(quat1, quat2)
    intermMatrix = [quat2(4), quat2(3), -quat2(2), quat2(1);
                    -quat2(3), quat2(4), quat2(1), quat2(2);
                    quat2(2), -quat2(1), quat2(4), quat2(3);
                    -quat2(1), -quat2(2), -quat2(3), quat2(4)];
    quatMul = (intermMatrix * quat1.').';
end

% Verified. 
% Euler to quaternion transformation. 
function quat = eul_to_quat(theta1, theta2, theta3)

    % Precompute half-angles. 
    t1 = theta1/2;
    t2 = theta2/2;
    t3 = theta3/2;

    % sines and cosines of half-angles. 
    c1 = cos(t1);  s1 = sin(t1);
    c2 = cos(t2);  s2 = sin(t2);
    c3 = cos(t3);  s3 = sin(t3);

    % Quaternion components. 
    q1 =  s1*c2*c3  -  c1*s2*s3;
    q2 =  c1*s2*c3  +  s1*c2*s3;
    q3 =  c1*c2*s3  -  s1*s2*c3;
    q4 =  c1*c2*c3  +  s1*s2*s3;

    % Pack into a row-vector. 
    quat = [q1, q2, q3, q4];
end

% Verified
% Outputs angular velocity change vector. 
function wDot = w_dot(J, meanMot, q, w)
    % Defines cosine matrix elements via quaternion elems.
    C13 = 2*(q(1)*q(3) + q(2)*q(4));
    C23 = 2*(q(2)*q(3) + q(1)*q(4));
    C33 = 1 - 2*(q(1)^2 + q(2)^2);
   
    % Defines intermediate matrices. 
    C = [0, -C33, C23;
        C33, 0, -C13;
        -C23, C13, 0];
    W = [0, -w(3), w(2);
         w(3), 0, -w(1);
         -w(2), w(1), 0];

    wDot = [inv(J)*((3*meanMot^2*C*J*[C13;C23;33]) + ...
           [0.001; 0.001; 0.001] - W*J*w(1:3)); 0];
end

% Outputs q_dot matrix. 
function qDot = q_dot(w, q)
    
    qDot = 

end